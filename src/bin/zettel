#!/usr/bin/env python3

# This file is part of Zettel.
#
# Copyright (c) Alexander Haase <ahaase@alexhaase.de>
#
# This project is licensed under the MIT License. For the full copyright and
# license information, please view the LICENSE file that was distributed with
# this source code.

import argparse
import collections.abc
import importlib
import yaml

import zettel


def getArgs() -> argparse.Namespace:
    """
    Parse command line arguments.

    This function parses the application's command line arguments and returns
    the :py:class:`argparse.Namespace` to access the passed argument values. If
    necessary, this function emits a usage message and raises an error on
    invalid arguments or values.


    :returns: A :py:class:`argparse.Namespace` to access the argument values.
    """
    parser = argparse.ArgumentParser()

    parser.add_argument('config',
                        type=parseConfig,
                        help='configuration file to use')

    # Parse the command line arguments and return the generated namespace. If
    # an argument is unknown, or its value does not match the specification, an
    # error message will be generated and the help message shown.
    return parser.parse_args()


def parseConfig(file: str) -> dict:
    """
    Parse the configuration file.

    This function opens a given ``file``, parses its YAML encoded contents and
    returns the configuration as dictionary.


    :param file: The file to be loaded.

    :returns: The parsed YAML configuration as dictionary.
    """
    with open(file) as f:
        return yaml.safe_load(f)


def fetchItems(providers: list) -> collections.abc.Iterable[zettel.Item]:
    """
    Fetch items from configured ``providers``.

    This function iterates over the given list of ``providers`` and temporary
    loads them. Then, the provider class will be used to fetch all items from
    the provider's backend, which will be passed through to the callee of this
    function.


    :param providers: The list of provider configurations to load items from.

    :returns: Items the configured providers did return.
    """
    for p in providers:
        # Load the provider's plugin as defined in the configuration and
        # initialize the provider class with its default name. Any options
        # defined in the configuration will be passed to the constructor.
        mod = importlib.import_module(p['name'])
        pro = mod.Provider(**p['opts'])

        # Fetch all items from this provider and pass them through to the callee
        # of this function.
        yield from pro.fetch()


# ========================
# Run the main application
# ========================

if __name__ == '__main__':
    # Parse the command line arguments. If necessary, this function will print
    # error messages and exits the application on errors.
    args = getArgs()

    # Create a storage object for all items and feed it with all items fetched
    # from the providers as defined in the configuration.
    items = list()
    items.extend(fetchItems(args.config['providers']))

    # Get the configured printing driver by loading the related module and
    # initializing the printing class as defined via API. All options defined in
    # the configuration will be passed through to the printing class. Entering
    # the printing context finally initializes the printer and shuts it down
    # when leaving the context.
    mod = importlib.import_module(args.config['printer']['name'])
    arg = args.config['printer'].get('opts', {})
    with mod.Printer(**arg) as printer:
        # Get the configured template module and run its printing function as
        # defined via API. The item storage and printing driver will be passed
        # as parameters, giving the template full controll about the
        # representation of the data. Additional options defined in the
        # configuration will be passed through to the function and can be used
        # to alter the templates functionality.
        template = importlib.import_module(args.config['template']['name'])
        template.printTemplate(items, printer,
                               **(args.config['template'].get('opts', {})))
